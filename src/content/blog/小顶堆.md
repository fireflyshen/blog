# 小顶堆

## 基本概念

1. 小顶堆是一个完全二叉树（简单理解为一个金字塔，从上到下，从左到右填满）
2. 父节点的值必须要小于等于子节点的值
3. 堆的最顶端一定是堆中最小的元素

## 代码实现

```java

public class MinHeap {
    private int[] heap;
    private int size;
    private int capacity;

    // 构造函数，初始化堆的容量
    public MinHeap(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.heap = new int[capacity];
    }

    // 获取父节点的索引
    private int getParentIndex(int index) {
        return (index - 1) / 2;
    }

    // 获取左子节点的索引
    private int getLeftChildIndex(int index) {
        return 2 * index + 1;
    }

    // 获取右子节点的索引
    private int getRightChildIndex(int index) {
        return 2 * index + 2;
    }

    // 交换两个节点的值
    private void swap(int index1, int index2) {
        int temp = heap[index1];
        heap[index1] = heap[index2];
        heap[index2] = temp;
    }

    // 插入新元素
    public void insert(int value) {
        if (size >= capacity) {
            throw new IllegalStateException("堆已满");
        }

        // 将新元素添加到堆的末尾
        heap[size] = value;
        // 向上调整堆
        heapifyUp(size);
        size++;
    }

    // 向上调整堆的结构
    private void heapifyUp(int index) {
        int parentIndex = getParentIndex(index);

        // 如果当前节点比父节点小，就交换它们
        if (index > 0 && heap[index] < heap[parentIndex]) {
            swap(index, parentIndex);
            // 递归继续向上调整
            heapifyUp(parentIndex);
        }
    }

    // 删除并返回堆顶最小元素

    public int extractMin() {
        if (size == 0) {
            throw new IllegalStateException("堆为空");
        }

        int min = heap[0];

        // 将最后一个元素放到堆顶
        heap[0] = heap[size - 1];
        size--;

        // 向下调整堆
        if (size > 0) {
            heapifyDown(0);
        }

        return min;
    }

    // 向下调整堆的结构
    private void heapifyDown(int index) {

        int smallest = index;
        int leftChild = getLeftChildIndex(index);
        int rightChild = getRightChildIndex(index);

        // 找出当前节点、左子节点和右子节点中的最小值
        if (leftChild < size && heap[leftChild] < heap[smallest]) {
            smallest = leftChild;
        }

        if (rightChild < size && heap[rightChild] < heap[smallest]) {
            smallest = rightChild;
        }

        // 如果最小值不是当前节点，就交换它们
        if (smallest != index) {
            swap(index, smallest);
            // 递归继续向下调整
            heapifyDown(smallest);
        }
    }

    // 查看堆顶元素（不删除）
    public int peek() {
        if (size == 0) {
            throw new IllegalStateException("堆为空");
        }
        return heap[0];
    }

    // 获取堆的大小
    public int getSize() {
        return size;
    }

    // 判断堆是否为空
    public boolean isEmpty() {
        return size == 0;
    }
}

```

## 代码解析

1. 其实堆的本质就是一个树，而树的本质实际上就是个数组，因此在内部通过数组维护这个树；
2.
